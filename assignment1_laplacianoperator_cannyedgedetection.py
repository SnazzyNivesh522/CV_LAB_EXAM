# -*- coding: utf-8 -*-
"""Assignment1_LaplacianOperator_CannyEdgeDetection.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1kwUwF2OC0Kuv77AaibF9_QGmPI1vuRco
"""

import cv2

import matplotlib.pyplot as plt

import numpy as np

image = cv2.imread('/content/drive/MyDrive/Colab Notebooks/CV/Lenna.png')
image_gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)

"""# LAPLACIAN OPERATOR FOR EDGE DETECTION"""

import numpy as np

def boundary_check(x, y, width, height):
    return 0 <= x < width and 0 <= y < height

def laplacian_filter(image):
    height, width = image.shape
    out_image = np.zeros_like(image)

    for i in range(height):
        for j in range(width):
            sum_ = 0
            for m in [-1, 1]:
                for n in [-1, 1]:
                    if boundary_check(j + n, i + m, width, height):
                        sum_ += image[i + m, j + n]
            temp = image[i, j] * 4 - sum_
            temp = np.clip(temp, 0, 255)
            out_image[i, j] = temp

    return out_image

def padding(image, pad_width, padding_type, fixed_value=0):
    height, width = image.shape
    padded_image = np.zeros((height + 2 * pad_width, width + 2 * pad_width), dtype=image.dtype)
    padded_image[pad_width:-pad_width, pad_width:-pad_width] = image

    if padding_type == "same":
        # Top and bottom border
        padded_image[:pad_width, pad_width:-pad_width] = image[0, :]
        padded_image[-pad_width:, pad_width:-pad_width] = image[-1, :]
        # Left and right border
        padded_image[:, :pad_width] = padded_image[:, pad_width:pad_width+1]
        padded_image[:, -pad_width:] = padded_image[:, -pad_width-1:-pad_width]

    elif padding_type == "fixed":
        padded_image[:pad_width, :] = fixed_value
        padded_image[-pad_width:, :] = fixed_value
        padded_image[:, :pad_width] = fixed_value
        padded_image[:, -pad_width:] = fixed_value

    return padded_image

def laplacian_convolve(image, padding_type, stride=1):
    height, width = image.shape
    padded_image = padding(image, 1, padding_type)

    filtered_image = laplacian_filter(padded_image)

    return filtered_image

image_gray.shape

# Define the Laplacian kernel
laplacian_kernel = np.array([[0, 1, 0],
                             [1, -4, 1],
                             [0, 1, 0]])

# Applying Laplacian Convolution
filtered_image = laplacian_convolve(image_gray, "same", 1)

# Thresholding to create a binary edge map
threshold = 50
binary_image = np.where(filtered_image > threshold, 255, 0)

fig,ax=plt.subplots(1,3,figsize=(15,12))
ax[0].imshow(image_gray,cmap="gray")
ax[0].set_title("Original Image")
ax[1].imshow(binary_image,cmap="gray")
ax[1].set_title("Threshold Binary Map Image")
ax[2].imshow(filtered_image,cmap="gray")
ax[2].set_title("Laplace filered Image")
plt.show()

"""#Canny Edge Detection using CV2"""

blurred = cv2.GaussianBlur(image_gray, (5, 5), 0)

canny = cv2.Canny(blurred, 50, 150)

fig,ax=plt.subplots(1,3,figsize=(15,12))
ax[0].imshow(image_gray,cmap="gray")
ax[0].set_title("Original Image")
ax[1].imshow(blurred,cmap="gray")
ax[1].set_title("Blurred Image")
ax[2].imshow(canny,cmap="gray")
ax[2].set_title("Canny Edges")
plt.show()

"""#Tried Implementating from scratch but got many errors and could not figure out"""

def gaussian_kernel_(kernel,std_dev=1):
  if kernel=="default":
    kernel_size=(6*std_dev)+1
  else:
    kernel_size=kernel
  gaussian_kernel=np.zeros((kernel_size,kernel_size))
  for i in range(-kernel_size//2+1,kernel_size//2+1):
    for j in range(-kernel_size//2+1,kernel_size//2+1):
      gaussian_kernel[i+kernel_size//2,j+kernel_size//2]=np.exp(-(i**2+j**2)/(2*std_dev**2))/(2*np.pi*std_dev**2)

  #normalized gaussian_kernel
  gaussian_kernel=gaussian_kernel/np.sum(gaussian_kernel)
  return gaussian_kernel

def gaussian_blur(image,kernel):
    kernel_size=kernel.shape[0]
    blurred_image = np.zeros_like(image)

    # Convolve the kernel with the image
    for i in range(image.shape[0]):
        for j in range(image.shape[1]):
            pixel_sum = 0
            for x in range(-kernel_size//2, kernel_size//2 + 1):
                for y in range(-kernel_size//2, kernel_size//2 + 1):
                    idx = (i + x + image.shape[0]) % image.shape[0], (j + y + image.shape[1]) % image.shape[1]
                    pixel_sum += kernel[x + kernel_size//2, y + kernel_size//2] * image[idx]
            blurred_image[i, j] = pixel_sum
    return blurred_image

def gradient_intensity_and_direction(image):


    Kx = np.array([[-1, 0, 1], [-2, 0, 2], [-1, 0, 1]],np.float32)
    Ky = np.array([[1, 2, 1], [0, 0, 0], [-1, -2, -1]],np.float32)

    Ix = gaussian_blur(image, Kx)
    Iy = gaussian_blur(image, Ky)

    G = np.hypot(Ix, Iy)
    G = G / G.max() * 255
    theta = np.arctan2(Iy, Ix)

    return (G, theta)

def non_maximum_suppression(G, theta):

    M, N = G.shape
    Z = np.zeros((M, N), dtype=np.int32)
    angle = theta * 180. / np.pi
    angle[angle < 0] += 180

    for i in range(1, M-1):
        for j in range(1, N-1):
            try:
                q = 255
                r = 255

                # Angle 0
                if (0 <= angle[i, j] < 22.5) or (157.5 <= angle[i, j] <= 180):
                    q = G[i, j+1]
                    r = G[i, j-1]

                # Angle 45
                elif (22.5 <= angle[i, j] < 67.5):
                    q = G[i+1, j-1]
                    r = G[i-1, j+1]

                # Angle 90
                elif (67.5 <= angle[i, j] < 112.5):
                    q = G[i+1, j]
                    r = G[i-1, j]

                # Angle 135
                elif (112.5 <= angle[i, j] < 157.5):
                    q = G[i-1, j-1]
                    r = G[i+1, j+1]

                if (G[i, j] >= q) and (G[i, j] >= r):
                    Z[i, j] = G[i, j]
                else:
                    Z[i, j] = 0

            except IndexError as e:
                pass

    return Z

def double_threshold(img, lowThreshold, highThreshold):

    highThreshold = img.max() * highThreshold
    lowThreshold = highThreshold * lowThreshold

    M, N = img.shape
    res = np.zeros((M, N), dtype=np.int32)

    strong_i, strong_j = np.where(img >= highThreshold)
    weak_i, weak_j = np.where((img <= highThreshold) & (img >= lowThreshold))

    strong = 255
    weak = 25

    res[strong_i, strong_j] = strong
    res[weak_i, weak_j] = weak

    return (res,weak,strong)

def hysteresis(img, weak=25, strong=255):

  M, N = img.shape
  for i in range(1, M-1):
      for j in range(1, N-1):
          if img[i, j] == weak:
              try:
                  if ((img[i+1, j-1] == strong) or (img[i+1, j] == strong) or (img[i+1, j+1] == strong)
                      or (img[i, j-1] == strong) or (img[i, j+1] == strong)
                      or (img[i-1, j-1] == strong) or (img[i-1, j] == strong) or (img[i-1, j+1] == strong)):
                      img[i, j] = strong
                  else:
                      img[i, j] = 0
              except IndexError as e:
                  pass
  return img

def canny_edge_detector(image, sigma, lowThreshold, highThreshold):
    # 1. Noise reduction (Gaussian filter)
    kernel=gaussian_kernel_(3,sigma)
    smoothed_image = gaussian_blur(image,kernel)

    # 2. Gradient calculation (Sobel)
    G, theta = gradient_intensity_and_direction(smoothed_image)

    # 3. Non-Maximum Suppression
    non_max_img = non_maximum_suppression(G, theta)

    # 4. Double Threshold
    threshold_img,weak,strong = double_threshold(non_max_img, lowThreshold, highThreshold)

    # 5. Edge Tracking by Hysteresis
    final_img = hysteresis(threshold_img,weak,strong)

    return final_img

canny_edges = canny_edge_detector(image_gray, 25, 0.05, 0.15)
fig,ax=plt.subplots(1,2,figsize=(15,12))
ax[0].imshow(image_gray,cmap="gray")
ax[0].set_title("Original Image")
ax[1].imshow(canny_edges,cmap="gray")
ax[1].set_title("Canny Edges")
plt.show()